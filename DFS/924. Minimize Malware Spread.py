class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        # 在允许恢复一个被感染节点的条件下，恢复哪个节点，能使得被感染节点数量最小化
        min_infected = float('inf')
        res = -1

        # step1: for loop each node in initial from small to large, remove current node to see number of infected nodes
        for removed_node in sorted(initial):
            visited = set()
            for node in initial:
                if node == removed_node:
                    continue
                if node not in visited:  # check which connected node will be infected
                    self.dfs(graph, visited, node)

                    # step2: check the minn size of infected node from each scenarios --> find removed node
            if len(visited) < min_infected:
                min_infected = len(visited)
                res = removed_node
        return res

    def dfs(self, graph, visited, node):
        visited.add(node)

        for nei, infected in enumerate(graph[node]):
            if nei not in visited and infected == 1:
                self.dfs(graph, visited, nei)
